\documentclass[12pt,letterpaper]{article}
\usepackage[greek,spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[right=2cm,left=3cm,top=2cm,bottom=2cm,headsep=0cm,footskip=0.5cm]{geometry}
\usepackage[pdftex]{graphicx}
\usepackage{color}
\usepackage{hyperref}
\usepackage[hypcap]{caption}
\usepackage{makeidx}
\usepackage{wynroTitle}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata,shapes}
\newcommand{\leftstack}[1]{%
{\begin{tabular}{l} #1\end{tabular}}}
\newcommand{\rightstack}[1]{%
{\begin{tabular}{r} #1\end{tabular}}}
\newcommand{\centerstack}[1]{%
{\begin{tabular}{c} #1\end{tabular}}}
\newcommand*{\blankpage}[1]{%
\vspace*{\fill}
\begin{center} \textit{#1} \end{center}
\vspace{\fill}
\clearpage}

\makeindex
\pagenumbering{arabic}

\logo{logoUZ.png}
\subject{Proyecto Hardware\\Trabajo de la asignatura}
\title{Implementación de un juego sudoku} %TODO: Cambiar
\author{Guillermo Robles González - NIP: 604409}
\supervisor{Javier Resano Ezcaray (coordinador)\\
María Villarroya Gaudó\\
Enrique Torres Moreno\\
Jesús Alastruey Benedé\\
Darío Suárez Gracia\\
\textcolor{white}{Dr. Emmett \textsc{Doc} Lathrop Brown}}

% It's Dangerous to Go Alone! Take This
\begin{document}
%% La MAGIA de tikz
\shorthandoff{>}
\shorthandoff{<}
% Primera pagina (Titulo)
\maketitle
%% Don't ask, don't say
\blankpage{Pagina intencionalmente en blanco.}
% Tercera pagina (Indice)
\tableofcontents
\clearpage
% El resto
\section{Resumen}
\label{sec:resumen}
% Es un apartado fundamental. Es lo primero que se lee y muchas*
% veces lo único que lee. Es la síntesis de todo el trabajo
% realizado, qué, cómo y por qué hemos hecho el trabajo. Debe ser
% auto contenido y debemos esbozar nuestras conclusiones.
% [*] todas
El trabajo a desarrollar consiste en 3 partes claramente
diferenciadas; la primera es el arreglado del problema de los rebotes,
creando un módulo que nos permita controlar entrada de señales del
boton ignorando señales espurias. La segunda parte consiste en el
aprendizaje del control de la pantalla, con todo el bagaje que la
misma conlleva. Finalmente, hemos de integrar todos los desarrollos
previos para crear un sistema de ayuda a la resolución de sudokus.\\

El trabajo fue desarrollado con satisfacción, cumpliendo (casi) todos
los objetivos marcados (especificados en la sección
\ref{sec:objetivos}), entre los que se incluyen tanto objetivos
marcados por el profesorado como objetivos auto impuestos por el
alumno, que considera este un proyecto de cierta envergadura, y la
oportunidad para usar tecnologías (sección \ref{sec:tecnologias}) de
un cierto calibre y complejidad, que quizás no son tan adecuadas para
otros de los proyectos o practicas.

\section{Introducción}
\label{sec:introduccion}
% Enmarca y sitúa el trabajo a realizar.
Apoyándonos sobre el trabajo desarrollado en la practica anterior, en
la cual se probaron distintos algoritmos para comprobar la correctitud
de sudokus, el desarrollo de esta practica consistió principalmente en
la eliminación del problema de los rebotes (módulo Button, sección
\ref{subsec:rebotes}) y la creación de una librería gráfica particular
(módulo sudoku\_graphics, sección \ref{subsec:graficos}) encargado de
actuar de Proxy entre el método Main y la librería Lcd, permitiéndonos
generalizar el método Main, de tal forma que en la situación en la
cual se desee llevar este proyecto a otro hardware solo se tendría que
cambiar el modulo Proxy (sudoku\_graphics), y no será necesario
modificar la función Main.  Esta propiedad de generalización ha sido
uno de los objetivos primarios de este proyecto, intentando siempre
que sea posible el mover cualquier función generalizable a su lugar
adecuado (Como ejemplo practico de esto, en el marcaje de errores se
ha elegido el marcar en negativo las casillas error, para ello se creó
una función que inicialmente estaba en el Main, pero primero fué
movida a sudoku\_graphics, y finalmente fué completamente generalizada
y movida a Lcd, de esta forma si en algún momento se ha de desarrollar
otro proyecto con este hardware, la librería ya esta preparada para
soportar más operaciones).

En general la realización de la practica fue satisfactoria, a
excepción de la mayor carga de trabajo por el hecho de realizarlo en
solitario, sin embargo este trabajo es perfectamente asumible.  Dada
la envergadura del trabajo, este era una gran oportunidad para probar
conjuntos de tecnologías, descritas con más detalle en la sección
\ref{sec:metodologias-tecnologias}, al igual que un conjunto de
metodologías de trabajo, descritas en la misma sección.

\section{Objetivos}
\label{sec:objetivos}
% Explica qué se quiere conseguir.
Los objetivos se organizan en 2 conjuntos, los objetivos propuestos
por el profesorado, y un conjunto de objetivos autopropuestos por el
alumno.

Objetivos del profesorado:
\begin{itemize}
  \item Dentro de la parte de tratamiento de rebotes tenemos los siguientes:
    \begin{itemize}
      \item Interactuar con una placa real y ser capaces de ejecutar
        en ella el código desarrollado en la práctica anterior.
      \item Profundizar en la interacción C / Ensamblador.
      \item Ser capaces de depurar el código ensamblador que genera un
        compilador a partir de un lenguaje en alto nivel.q
      \item Ser capaces de depurar un código con varias fuentes de interrupción activas.
      \item Gestionar la entrada/salida con dispositivos básicos, asignando
        valores a los registros internos de la placa desde un programa en C
        (utilizando las librerías de la placa).
      \item Aprender a desarrollar en C las rutinas de tratamiento de
        interrupción.  Aprender a utilizar los temporizadores internos de la
        placa y el teclado.
    \end{itemize}
  \item Dentro de la segunda parte
    \begin{itemize}
      \item Finalizar el proyecto en el que habéis estado trabajando
        hasta conseguir un sistema empotrado autónomo de los
        ordenadores del laboratorio con el que se pueda jugar
        directamente.
      \item Utilizar la pantalla LCD para visualizar el tablero.
      \item Cargar el código en la memoria Flash de la placa mediante
        el estándar JTAG, de forma que al encenderla se pueda jugar
        sin necesidad de conectarse ni descargar el programa.
    \end{itemize}
\end{itemize}

Objetivos del alumno:
\begin{itemize}
  \item Uso de una adecuada disciplina de diseño, orientada a la
    generalización de funciones y funcionalidades.
  \item Organizado del código adecuada, uso de archivos .h, separación
    del sistema en los módulos adecuados.
  \item Uso de un sistema de documentado en código estandar (Doxygen)
  \item Uso de un sistema de control de versiones (Git)
\end{itemize}

\section{Partes del proyecto}
\label{sec:partes}
\subsection{Trabajo previo}
\label{subsec:previous}
El trabajo a realizar requiere un conjunto de funcionalidades previas,
que pese a no estar explicitamente incluidas en el producto final, nos
permiten desarrollar adecuadamente las secciones siguientes, ya sea tanto porque ofrecen funcionalidad en la que se basan(como es el caso de los \hyperref[subsubsec:timers]{timers}). Estas
funcionalidades son:
\begin{itemize}
  \item Conocimiento del funcionamiento de los timers, y uso de los
    mismos tanto para medidas de tiempo como para programar tareas.
  \item Implementado de una sencilla pila de debug, que nos permite
    almacenar estampillas temporales e informacion deseada, y nos
    simplifica por ejemplo medir cual es el tiempo que duran los
    rebotes.
  \item Manejo de excepciones, tanto para informar al programador como
    para eventualmente resolveralas y recuperarnos de las mismas.
\end{itemize}

\subsubsection{Timers}
\label{subsubsec:timers}
El control de sucesos temporales es vital, tanto para ejecutar
funciones periódicamente (por ejemplo, capturas de datos) como con un
cierto retardo (por ejemplo, esperas).

En el proyecto, el uso de los timers en los rebotes es usado tanto
para el control de los tiempos en los cuales ignoramos entradas como
para medir los periodos de autorrepetición. Basado en el proyecto dado
(Un sencillo programa que parpadea alternativamente 2 leds) se pudo
generalizar una simple librería de tiempos que cumplía las
caracteristicas necesitadas. El timer usado es el 2, lo cual deja
también el 3 inutilizable, o, al menos, con la misma configuración
temporal.

La unidad de medida inicial elegida fueron los \textgreek{m}segundos,
que posteriormente fué cambiado a milisegundos, dado que en la medida
de tiempos de juego (que pueden llegar a las horas) ocurrían problemas
de overflow. Sin embargo, esto podía producir problemas, dado que gran
cantidad de las funciones, por ello se modifico la libreria Timer2
para guardar no solo el número de \textgreek{m}segundos pasados, sino
también los segundos por separado en su propia variable. Tras este
cambio la nueva libreria permite contar hasta 4294967296 segundos, o
algo más de 136 años, lo que debería eliminar cualquier posible
problema de overflow.
\subsubsection{Pila de Debug}
\label{subsubsec:pila-debug}
Una pila (lo llamamos pila pero la estructura implementada sería más
cercana a una cola circular) de Debug es una zona especial de la
memoria, en la cual introducimos información que podemos consultar,
que en nuestra situación es usada para reconocer y ordenar sucesos
temporales, como excepciones o interrupciones, que guarda una
estampilla temporal, un suceso e información extra acerca del mismo.

En nuestro caso la pila se ha escogido de tamaño 20 sucesos, situada
en la zona de las pilas, por debajo de la pila de usuario, de tal
forma que podamos localizarla con facilidad.

Esta pila utiliza el Timer programado previamente para la generación
de las estampillas temporales, por lo que para su correcto
funcionamiento el módulo Timer2 ha de ser inicializado por el usuario
de esta pila.

\subsubsection{Excepciones}
\label{subsubsec:excepciones}
Las excepciones son sucesos inesperados, generalmente asociados a
situaciones de error, que nos permiten reconocer situaciones
inesperadas, y advertir al programador, al usuario o incluso intentar
recuperarnos de la misma, tanto para continuar el programa como para
finalizarlo suavemente.

El procesador ya incluye un sencillo sistema de gestión de
Excepciones, que simplemente atasca o reinicia la placa. manejar este
sistema simplemente se han de cambiar los punteros
\texttt{pISR\_UNDEF}, \texttt{pISR\_SWI}, \texttt{pISR\_PABORT},
\texttt{pISR\_DABORT} a una función, que será llamada en la situación
de que salte alguna de las excepciones.
Las excepciones que podemos tratar en el procesador usado son:
  \begin{center}
    \begin{tabular}{ r | r | r}
      Puntero                & Excepción que lo llama  & Descripción                                 \\
      \hline
      \texttt{pISR\_RESET}   & Reset                   & Reset por hardware de la placa              \\
      \texttt{pISR\_UNDEF}   & Undefined Instruction   & Opcode(instrucción) no reconocido           \\
      \texttt{pISR\_SWI}     & Software Interrupt(SWI) & Lanzado mediante la instrucción swi         \\
      \texttt{pISR\_PABORT}  & Prefetch Abort          & Error al realizar el fetch de instrucción   \\
      \texttt{pISR\_DABORT}  & Data Abort              & Error al leer argumentos de una instrucción \\
    \end{tabular}
  \end{center}

Para reconocer la excepcion en la cual nos encontramos se puede mirar
el modo de procesador, dado que el lanzado de ciertas excepciones
fuerza el procesador a modos particulares, por lo que mirando el modo
actual se puede detectar la excepción lanzada, tanto para intentar
recuperar (por ejemplo, en el caso de SWI) como para poder reconocer y
guardar la excepción ocurrida.

Una situación en la cual no se puede reconocer la excepción por el
modo es entre \texttt{pISR\_PABORT} y \texttt{pISR\_DABORT}, dado que
ambas pasan al modo \texttt{Abort}; o entre \texttt{pISR\_RESET} y
\texttt{pISR\_SWI} dado que ambas pasan al modo \texttt{Supervisor};
en estos casos la única posibilidad es utilizar varias funciones
gestoras, de tal forma que por la propia función en la que estemos nos
indique que excepción estamos manejando.

Dado el alcance de este proyecto, no se ha decidido complicar la
librería de gestión de excepciones con estas consideraciones, pero en
una situación en la cual este módulo quiera generalizarse, habría que
tener en cuenta tanto la gestión correcta de algunas excepciones (por
ejemplo \texttt{pISR\_RESET}) como la recuperación de aquellas que lo
sean (como \texttt{pISR\_SWI}).

\subsection{Rebotes en los botones}
\label{subsec:rebotes}
El problema de los rebotes ha sido uno de los primeros problemas a los
que tenemos que enfrentarnos en un proyecto de estas caracteristicas,
y uno de los más complejos.

Este problema aparece cuando nos enfrentamos a hardware (botones)
reales. Mientras un botón teórico da una señal similar a la siguiente:
%% TODO: rellenar
Un botón real sigue un patrón más cercano a este:
%% TODO: rellenar

Cuando hablamos de rebotes nos referimos al conjunto de señales
espurias que da un botón cuando es pulsado o soltado (algunos incluso
mientras son pulsados). Estos rebotes son un problema grave, dado que
mientras el usuario cree que ha pulsado el botón una única vez
(asumiendo como una vez una pulsación y un soltado) el sistema ha
recibido múltiples pulsaciones, y por tanto reacciona a todos ellos
(en nuestro caso, el sistema incrementa su contador interno múltiples
veces).

Existen múltiples soluciones a este problema, tanto por hardware como
por software.

Dentro de los solucionadores por hardware aparecen 2 grandes grupos,
los basados en SR latches y los basados en circuitos RC, ambos
suficientemente efectivos para la mayoría de situaciones, y
ampliamente usados en circuitos reales.

Desafortunadamente, el hardware escogido no posee estos sistemas, lo
cual nos fuerza a utilizar solucionados por software. Al igual que
para el solucionado por hardware, para el solucionado por software
existen múltiples sistemas, entre los que encontramos:
\begin{itemize}
  \item Sencillo sistema de polling, mediante el cual se compruebe el
    estado del botón con una cierta frecuencia (por ejemplo 250 ms) y
    si el botón esta pulsado, se realiza la acción asociada. Este
    sistema tiene el beneficio de que su implementación es trivial,
    pero es bastante poco efectivo (por ejemplo, si el usuario
    comienza a realizar pulsaciones fuera de fase respecto de las
    encuestas, el sistema no detectaría ninguna pulsación)
  \item Contar el número de ``pulsaciones''(pulsaciones reales y
    rebotes), y solo realizar la acción cada x pulsaciones. Este
    sistema tiene el beneficio de que es incluso más simple de
    implementar, pero dado que los botones usados no son consistentes
    en el conteo de rebotes, se abandono esta posibilidad.
  \item Iniciar un contador en el momento en el que llegue una
    ``pulsación'', e ignorar cualquier pulsación en los siguientes x
    milisegundos, en el caso en el que se desee añadir autorrepetición,
    gestionarla mediante un sistema de encuesta similar al primero
    descrito.
\end{itemize}

Para el proyecto en cuestión se ha elegido el último algoritmo, que,
siendo relativamente simple de implementar, nos ofrece bastante
protección frente a los rebotes, además de permitir integrar funciones
como la autorrepetición

En nuestro caso, se ha decidido realizar una modificación al algoritmo
simple, añadiendo la posibilidad de autorrepetición, es decir, que el
botón actuará mientras sea pulsado (a una frecuencia deseada).


Habiendo elegido el algoritmo, es necesario decidir como se
implementará. Para ello, se genera la siguiente máquina de estados:
%% TODO: rellenar

\begin{figure}
\footnotesize
\centering
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=5cm,semithick]
    \tikzstyle{every state}=[fill=red,draw=none, ellipse, text=white]
    \node[initial,state] (A)                    {reposo};
    \node[state]         (B) [above right of=A] {espera\_TRP};
    \node[state]         (C) [below right of=B] {desactivado};
    \node[state]         (D) [below right of=A] {espera\_TRD};  
    \path (A) edge              node {\leftstack{PULSA/\\
                                      Desactivar interrupciones\\accion()\\cuenta=0}} (B)
          (B) edge [loop above] node {\leftstack{CLK(10ms) \& cuenta \textless 15/ \\cuenta = 0}} (B)
              edge              node {\leftstack{CLK(10ms) \& cuenta = 15/\\cuenta = 0}} (C)
          (C) edge [loop right] node {\leftstack{CLK(10ms) \&\\\hspace{1cm}PULSA/\\cuenta++\\
                                      if(cuenta = 30) \{\\\hspace{0.25cm} accion()\\
                                      \hspace{0.25cm} cuenta=0\\\}}} (C)
              edge              node {\leftstack{CLK(10ms) \& !PULSA/\\cuenta = 0}} (D)
          (D) edge [loop below] node {\leftstack{CLK(10ms) \& cuenta \textless 20/\\cuenta++}} (D)
              edge              node {\leftstack{CLK(10ms) \& cuenta = 20/\\
                                      Eliminar interrupciones pendientes\\Reactivar interrupciones}} (A);
  \end{tikzpicture}
  \caption{Diagrama de estado del sistema de botones} 
  \label{fig:maquina-estados-boton}
\end{figure}

En nuestro caso, el botón solo reacciona a 2 señales, la interrupción
de pulsado (indicada en el diagrama con PULSA) y la interrupción de
reloj interna (ofrecida por el Timer4, con una frecuencia de 10ms,
indicada como CLK(10ms)).

Como se describe en la Figura \ref{fig:maquina-estados-boton}.\\
No se ha encontrado ningún problema destacable en el implementado, a
excepción quizás de la determinación de los valores TRP y TRD (ciclos
de 10ms de espera en pulsado y en soltado, respectivamente). Para la
determinación de los mismos se ha usado la pila de Debug ya comentada,
que nos permite conocer el número de interrupciones que lanza los
botones en cuestión en que intervalo de tiempo. Cabe destacar que se
han elegido unos tiempos algo mas grandes de lo estrictamente
necesario, sin embargo, se ha tomado esta decisión para permitir que
el algoritmo pueda comportarse adecuadamente en las distintas placas
en las cuales se ha probado, aunque se pierda algo de eficacia en
situaciones en las cuales el usuario pulse los botones a gran
velocidad (situaciones que, de todas formas, no tienen razón para
aparecer en el sistema desarrollado).

\subsection{Interaccion y Ejecución del sistema}
\label{subsec:interaction-ejecucion}
La interacción se realiza principalmente a través de los 2 botones de
la placa. 
Por comodidad, el juego se ha separado en un conjunto de menús, cada
uno con una función asociada en sudoku\_graphics, estos menús son
\texttt{title\_screen}, \texttt{final\_screen}, \texttt{aperture},
\texttt{instructions}, \texttt{sudoku}. Cada menú tiene asociado un
estado, a excepción del menú \texttt{sudoku}, que contiene 3 estados
(\texttt{esperando\_fila}, \texttt{esperando\_columna},
\texttt{esperando\_valor}). El menú \texttt{aperture} contiene a su
vez 119 subestados, que consisten en las distintas líneas de los
créditos, pero no se consideraba que mereciera la pena el añadir otros
119 estados al espacio de estados actual. Este subestado es mantenido
por la variable \texttt{iterador\_aperture}. 

La organización de este espacio de estados se muestra en el siguiente
diagrama de estados:
%% TODO: añadir diagrama de estados


\subsection{Gráficos}
\label{subsec:graficos}
Para la gestión de los gráficos se ha intentado desplazar todo el
sistema al módulo sudoku\_graphics, que se encarga de gestionar toda
la comunicación con la pantalla, ofreciendo una interfaz de alto nivel
(con funciones como sudoku\_graphics\_fill\_from\_data(cuadricula),
que rellena la pantalla con los numeros de la cuadrícula pasada). Este
modelo de abstracción nos permitiría reutilizar el codigo de la
función Main en caso de desear llevar un sistema similar.

En cualquiera de los casos en los que ha sido posible, se ha utilizado
el sistema de macros del preprocesador de C para crear código
adaptable, de tal forma que si se deseara cambiar la resolución de
funcionamiento, o cambiar la fuente de escritura, se pueda hacer sin
más que cambiar las pocas macros que describen tamaños relativos y
posiciones. Esto tiene el efecto de que la cuadricula en la pantalla
no es tan grande como pudiera, dado que para poder adaptarse
correctamente, las medidas han de cumplir ciertas propiedades (este
problema se describe con más detalle en el propio fichero fuente
\texttt{sudoku\_graphics.h})\\

La actualización de los graficos es uno de los temas que mas
complicaciones ha traido, mas exactamente la decisión del momento de
actualización de la pantalla.

En el proyecto inicialmente mandado, solo existían 2 posibles fuentes
de actualización de la pantalla (el momento en el cual el usuario
introducía un número y el momento en el que avanzaba el reloj), por lo
que se podía montar un sistema de actualización a demanda, en el cual
simplemente se actualizan ciertas zonas de la pantalla en ciertos
momentos (Por ejemplo, la zona en la que mostramos el reloj en el
momento en el que este cambie).

Sin embargo, algunas de las extensiones que se han decidido realizar
(principalmente, la adición de un cursor, que permite eliminar
completamente el 8 segmentos del proyecto; y también la adición de
algunas animaciones simples) provocan que aparezcan más fuentes de
posible actualización, por lo que se tomó la decisión de cambiar a un
sistema de actualización constante, que refresca la pantalla siempre
que sea posible, eliminando todo el contenido y recalculándolo de
nuevo. Esto tiene algunos efectos negativos, entre ello, si cambia el
segundo durante una actualización de la pantalla, un segundo en la
pantalla puede durar ligeramente más que un segundo real, pero como se
mantiene perfectamente la cuenta interna, se considera un problema
asumible. Otro de los problemas que aparece es una ligera sensación de
parpadeo, pero dado que solo aparece en uno de los sistemas de prueba,
tampoco se considera alarmante.\\

Para la organización del sistema se a utilizado un
modelo-vista-controlador, en la cual el controlador es proporcionado
por la función Main, que se encarga de actualizar la vista,
consistente en la pantalla, siguiendo la información del modelo, que
se reparte entre el modulo botón y la función Main (esto es contrario
a la filosofía de encapsulamiento, y provoca que, por ejemplo, el
modulo Boton no sea todo lo general que pudiera, esto se comenta con
más profundidad en la sección \ref{sec:mejora}). Los beneficios de
usar un modelo como este son inmediatos, dado que nos permite manejar
con comodidad múltiples fuentes de información (botones, sudoku,
tiempo...) y múltiples presentaciones de la información (pantalla,
cuadricula...), y mantenerlos sincronizados sin problemas.

\section{Metodología y tecnologías}
\label{sec:metodologias-tecnologias}
\label{sec:metodologias}
\label{sec:tecnologias}
Para la organización de tareas a alto nivel, se ha utilizado un modelo
orientado a objetivos, de tal forma que cada objetivo propuesto se
dividía en un conjunto de subobjetivos, repitiendo el proceso de
manera recursiva hasta llegar a tareas que se consideraban asumibles
por sí solas, las cuales eran asignadas una prioridad, y a
continuación eran añadidas al conjunto de tareas para hacer.

Dentro de cada día o sesión de trabajo, se seleccionaban las tareas de
más prioridad del conjunto de tareas, y utilizando un sistema de
planificación a corto plazo basado en la conocida
\href{https://en.wikipedia.org/wiki/Kanban\_board}{tabla kanban}, se
conseguía una visualización clara de las tareas actuales, además de
permitir organizar fácilmente las tareas por prioridad, evitando que
el desarrollo divague.

Respecto a la organización y priorización de funcionalidades, se a
optado por jugabilidad y extensibilidad antes que optimización. En el
proyecto, cada fichero .h representa uno de los módulos, a excepción
de la carpeta resources/, que almacena los BitMap usados y algunas de
las cadenas de texto largas, para separar los datos del código.

Para la realización del presente documento se ha seleccionado el
sistema de maquetación y control tipográfico \TeX, con ayuda del
conjunto de macros \LaTeX. Pese a ser algo más complejo que otros
sistemas de maquetado del mercado (como suites ofimáticas o Scribus),
ofrece un nivel de calidad bastante mayor, además de tener
características especialmente orientadas al desarrollo de documentos
de índole técnica o científica, como el presente.

Para el control de versiones se ha elegido el sistema Git, utilizando
el servicio \href{https://www.github.com}{GitHub}, que ofrece la
posibilidad de gestionar repositorios online, ademas de un conjunto de
herramientas extra que simplifican el desarrollar un proyecto de
cierta magnitud
(\href{https://www.github.com/wynro/proyecto\_hardware}{Repositorio}). Dado
que los ordenadores del laboratorio en el cual se ha desarrollado la
practica no disponia del software necesario, ha sido imposible seguir
ninguno de los flujos de trabajo recomendados. Pese a ello, el sistema
de control de versiones ayudó a resolver varios problemas durante el
desarrollo (principalmente, \href{regresiones de
  software}{https://en.wikipedia.org/wiki/Software\_regression})

Como entorno de desarrollo se ha utilizado Eclipse, dado que era el
ofrecido por el profesorado, con la ToolChain GNU, que nos permitía la
compilación para sistemas particulares (En nuestro caso el procesador
ARMv7 de la placa de pruebas)

Como sistema/estandar de documentación en codigo se ha elegido
\href{http://www.stack.nl/~dimitri/doxygen/}{Doxygen}, aunque por
falta de tiempo y fuerza de trabajo no ha sido posible documentar
adecuadamente todos los módulos usados.
\section{Resultados y características}
\label{subsec:resultados-caracteristicas}
El sistema, aparte de las características mandadas por el profesorado,
tiene un conjunto de características que, aunque no explícitamente
mandadas, se considera que mejoran la experiencia del usuario. Entre
dichas caracteristicas aparecen:
\begin{itemize}
  \item \textbf{Extensión del módulo Lcd:} El módulo ofrecido por el
    profesorado era bastante pobre, por ello se ha extendido con
    algunas funciones que nos permiten generalizarlo más. Algunas de
    las mejoras propuestas han sido funciones que ofrecen más
    capacidades a una funcionalidad existente, como el dibujado de
    líneas punteadas. Otra de las funcionalidades experimentadas
    (aunque no realmente usadas en la practica) es la conversion de la
    función \texttt{Lcd\_Dma\_Trans()} en una función no bloqueante,
    mediante la eliminación de la espera frente al flag.
    \texttt{ucZdma0Done}. Esto provoca otro conjunto de posibles
    problemas (principalemente de sincronización, dado que hemos de
    evitar el escribir en el buffer virtual mientras se realiza el
    DMA, bajo riesgo de provocar problemas como el tearing, que
    complican desproporcionadamente la gestión del renderizado) que se
    considera que escapan al nivel de esta practica.
  \item \textbf{Pantalla de menú principal:} Además de ofrecer una
    interfaz de bienvenida más amigable al usuario, nos permite
    seleccionar la visualización de instrucciones o de jugar
    directamente, esto evita al usuario el tener que releer las
    instrucciones cada vez que desee jugar. Como característica de
    Debug, preparada exclusivamente de cara a la presentación, se
    ofrece la posibilidad de escoger una cuadricula casi resuelta, de
    tal forma que se pueda observar la reacción del sistema frente a
    la resolución del sudoku, sin necesidad de resolverlo del todo, o
    utilizar atajos.
  \item \textbf{Cursor e información en pantalla:} Ambos elementos
    juntos permiten abandonar completamente el 7 segmentos, dando al
    usuario toda la información necesaria de otro modo (la casilla
    seleccionada mediante el cursor, y el valor a escribir mediante la
    pantalla). Actualmente el 7 segmentos esta únicamente activo por
    la información de Debug que ofrece. Ademas de un cursor para
    seleccionar la casilla, se usa un cursor algo más pequeño, que se
    superpone al mostrado de los errores, y permite ver rápidamente si
    el número que se va a introducir esta dentro de los candidatos.
  \item \textbf{Múltiples cuadriculas:} Se ha añadido todo el sistema
    necesario para la inserción de múltiples cuadrículas. En el
    sistema mostrado se ofrece como ejemplo 10 cuadriculas a resolver,
    entre las cuales se escoje aleatoriamente al comenzar el juego y
    una cuadricula de Debug. Uno de los problemas comprobados es el
    gran tamaño que ocupa una cuadrícula (Actualmente, una ocupa 2304
    bits, o 288 bytes, que aunque inicialmente parece poco, si se
    desea introducir 1000 posibles tablas, comenzamos a movernos sobre
    los 281 KiB). Para gestionar esto, se plantea la posibilidad de
    utilizar un sencillo algoritmo de compresión, que nos permitiría
    reducir el espacio ocupado en un factor de 7\footnotemark. Esto
    introduciría un pequeño coste en el sistema de decodificación de
    la cuadrícula compresa, pero se considera un coste asumible, dado
    el valor que tiene el espacio en memoria en una aplicación
    embebida.

    \footnotetext{Exactamente el sistema consistiría en recortar
      exclusivamente los primeros 4 bits de cada cuadro en la
      cuadricula de tal forma que un numero ocupe solo 4 bits, de tal
      forma que cada par de numeros se guarde en un único char, y
      eliminar el padding de 7 columnas extra introducidas en la
      practica 1, por lo que una tabla completa ocuparía solo 41
      bytes, y nuestras 1000 tablas previas se moverían ahora sobre
      los 40 KiB, lo cual es una mejora importante}
    
    La otra posibilidad para ofrecer la posibilidad de usar distintas
    tablas en cada partida es la generación procedural de las mismas,
    sin embargo, esta posibilidad introduce otro conjunto de problemas
    (generación de numeros aleatorios, creación de cuadriculas,
    eliminación de números de cuadriculas para crear distintas
    dificultades...)  que se considera que escapan al alcance de esta
    practica.
  \item \textbf{Adición de pantalla final y creditos:} Otra
    característica que, aunque no mejora realmente el propio juego,
    ofrece una mejor experiencia de uso, dado que los creditos solo se
    muestran en el caso de resolver correctamente el sudoku,
    provocando una reacción de búsqueda del premio. No estrictamente
    relacionado, los créditos muestran la gestión de alguna animación
    simple, más específicamente la de texto moviéndose. Para la
    gestión de animaciones se utiliza el reloj maestro Timer2, y
    mediante un sencillo sistema de conteo, se decide cuando se debe
    cambiar de cuadro, provocando la sensación visual de movimiento.
    Este sistema es relativamente sencillo, y podría expandirse para
    la gestión de annimaciones bastante más complejas.
\end{itemize}

Se descartaron las posibles mejoras ofrecidas por el profesorado,
tanto la introducción de información por otros medios, como el uso de
más periféricos. Este aspecto se expande en la sección
\ref{sec:mejora}.
\section{Conclusiones}
%% TODO: rellenar
% Es lo último que se lee, por tanto es una sección muy importante
% que se debe utilizar para remarcar los mensajes que queremos que
% el lector reciba. Por ejemplo, si estamos evaluando un producto
% podemos enfatizar sus puntos fuertes y sus puntos débiles, y
% señalar posibilidades de mejora. Normalmente al final se incluyen
% referencias, bibliografía, índice de expresiones técnicas y
% anexos.
La finalización del trabajo fué satisfactoria, cumpliendo la mayoría
de los objetivos propuestos.


\subsection{Margen de mejora}
\label{sec:mejora}
%% Y ahora, me pasaré 15 minutos de autocrítica
\begin{itemize}
  \item El módulo Boton no es suficientemente general, dado que esta
    integrado tanto el control del 7 segmentos como algunas variables
    de control (next, update...). Esto se podría arreglar haciendo que
    en el constructor el botón reciba 2 punteros a función, que serán
    las que llamará cuando sea pulsado alguno de los botones; además
    de un conjunto de parámetros (Si el botón tiene autorepetición,
    tiempo de repetición...). No se ha realizado dado que se considera
    que complicaría el trabajo innecesariamente.
  \item Muchas de las funciones creadas para tratar textos, tanto
    fijos como en movimiento, podrían ser refactorizadas a su propio
    módulo TextUtils con dependecia de Lcd, persiguiendo el ya
    mencionado objetivo de una correcta organización del código. No se
    ha realizado por falta de fuerza de trabajo.
  \item Por falta de tiempo, no ha sido posible añadir música ni
    efectos de sonido. No ha sido posible por la dificultad del mismo.
  \item Las animaciones de los creditos son bastante crudas, y tienen
    posibilidad de mejorar. Una opción sería añadir suavizado,
    provocando que los créditos se muevan más lentamente. No se ha
    realizado por falta de tiempo.
  \item Un elemento que se considera que mejoraría bastante sería la
    introducción de un sistema de puntuación (Algo tan sencillo como
    una media ponderada del numero de errores durante la partida con
    el numero de segundos que haya durado sería suficiente), lo cual
    permitiría la creación de una tabla de los jugadores con más
    puntos, que podría almacenarse en la memoria no volátil de la
    placa entre encendidos.
  \item Respecto a los elementos de posible mejora ofrecidos por el
    profesorado:
    \begin{itemize}
    \item La pantalla táctil fue descartada porque se consideró que no
      sería aprovechada a menos que se pensara de nuevo todo el modelo
      de interacción, y dadas las fuertes restricciones de tiempo
      sufridas, dicho refactorizado no parecía adecuado. En cualquier
      caso, algunos de los experimentos realizados demostraron que el
      modo de interacción no era demasiado adecuado, dado que con el
      tamaño de cuadrícula usado, una tarea tan trivial como
      seleccionar una casilla se podía convertir en una tarea
      frustrante.
    \item El puerto serie fue descartado porque no parecía un modo
      adecuado de interactuar con un sistema de estas características
      (Sin embargo, se puede notar como un sistema así permitiría, por
      ejemplo, un teclado externo).
    \item El teclado matricial fue el único elemento de interacción
      que se vio que ofrecía posibilidades que sobrepasaban su coste
      de implementación, sin embargo la falta de fuerza de trabajo y
      el momento tardío en el que se consideró su introducción obligó
      a abandonar esa línea de trabajo.
    \end{itemize}
\end{itemize}
\clearpage
\section{Bibliografía}
\begin{itemize}
  \item Manuales de consulta ofrecidos por el profesorado
  \item Proyectos de la placa ofrecidos por el profesorado
  \item \url{http://www.eng.utah.edu/~cs5780/debouncing.pdf}
  \item \url{http://infocenter.arm.com/help/index.jsp} (Especialmente el
    manual de referencia de ARM7)
    % Little semicolono
    % that makes me not compile this,
    % where are you missing?
  \item \url{http://www.sudoku-solutions.com/}
\end{itemize}
\end{document}
